// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_GRAPHICSYSTEM_SCHEMA_SYSTEMS_H_
#define FLATBUFFERS_GENERATED_GRAPHICSYSTEM_SCHEMA_SYSTEMS_H_

#include "flatbuffers/flatbuffers.h"

#include "Common_generated.h"

namespace Schema {
struct vector2;
struct Property;
struct SystemObject;
struct Object;
struct System;
}  // namespace Schema

namespace Schema {
namespace Systems {

struct ResourceLocation;
struct GraphicSystem;

struct ResourceLocation FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  const flatbuffers::String *name() const { return GetPointer<const flatbuffers::String *>(4); }
  const flatbuffers::String *type() const { return GetPointer<const flatbuffers::String *>(6); }
  const flatbuffers::String *group() const { return GetPointer<const flatbuffers::String *>(8); }
  uint8_t recursive() const { return GetField<uint8_t>(10, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 4 /* name */) &&
           verifier.Verify(name()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 6 /* type */) &&
           verifier.Verify(type()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 8 /* group */) &&
           verifier.Verify(group()) &&
           VerifyField<uint8_t>(verifier, 10 /* recursive */) &&
           verifier.EndTable();
  }
};

struct ResourceLocationBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) { fbb_.AddOffset(4, name); }
  void add_type(flatbuffers::Offset<flatbuffers::String> type) { fbb_.AddOffset(6, type); }
  void add_group(flatbuffers::Offset<flatbuffers::String> group) { fbb_.AddOffset(8, group); }
  void add_recursive(uint8_t recursive) { fbb_.AddElement<uint8_t>(10, recursive, 0); }
  ResourceLocationBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  ResourceLocationBuilder &operator=(const ResourceLocationBuilder &);
  flatbuffers::Offset<ResourceLocation> Finish() {
    auto o = flatbuffers::Offset<ResourceLocation>(fbb_.EndTable(start_, 4));
    return o;
  }
};

inline flatbuffers::Offset<ResourceLocation> CreateResourceLocation(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<flatbuffers::String> name = 0,
   flatbuffers::Offset<flatbuffers::String> type = 0,
   flatbuffers::Offset<flatbuffers::String> group = 0,
   uint8_t recursive = 0) {
  ResourceLocationBuilder builder_(_fbb);
  builder_.add_group(group);
  builder_.add_type(type);
  builder_.add_name(name);
  builder_.add_recursive(recursive);
  return builder_.Finish();
}

struct GraphicSystem FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  const flatbuffers::String *windowName() const { return GetPointer<const flatbuffers::String *>(4); }
  const Schema::vector2 *resolution() const { return GetStruct<const Schema::vector2 *>(6); }
  const Schema::vector2 *shadowTexture() const { return GetStruct<const Schema::vector2 *>(8); }
  const Schema::vector2 *fsAntiAliasing() const { return GetStruct<const Schema::vector2 *>(10); }
  uint8_t verticalSync() const { return GetField<uint8_t>(12, 0); }
  const flatbuffers::Vector<flatbuffers::Offset<ResourceLocation>> *resources() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ResourceLocation>> *>(14); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 4 /* windowName */) &&
           verifier.Verify(windowName()) &&
           VerifyField<Schema::vector2>(verifier, 6 /* resolution */) &&
           VerifyField<Schema::vector2>(verifier, 8 /* shadowTexture */) &&
           VerifyField<Schema::vector2>(verifier, 10 /* fsAntiAliasing */) &&
           VerifyField<uint8_t>(verifier, 12 /* verticalSync */) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 14 /* resources */) &&
           verifier.Verify(resources()) &&
           verifier.VerifyVectorOfTables(resources()) &&
           verifier.EndTable();
  }
};

struct GraphicSystemBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_windowName(flatbuffers::Offset<flatbuffers::String> windowName) { fbb_.AddOffset(4, windowName); }
  void add_resolution(const Schema::vector2 *resolution) { fbb_.AddStruct(6, resolution); }
  void add_shadowTexture(const Schema::vector2 *shadowTexture) { fbb_.AddStruct(8, shadowTexture); }
  void add_fsAntiAliasing(const Schema::vector2 *fsAntiAliasing) { fbb_.AddStruct(10, fsAntiAliasing); }
  void add_verticalSync(uint8_t verticalSync) { fbb_.AddElement<uint8_t>(12, verticalSync, 0); }
  void add_resources(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ResourceLocation>>> resources) { fbb_.AddOffset(14, resources); }
  GraphicSystemBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  GraphicSystemBuilder &operator=(const GraphicSystemBuilder &);
  flatbuffers::Offset<GraphicSystem> Finish() {
    auto o = flatbuffers::Offset<GraphicSystem>(fbb_.EndTable(start_, 6));
    return o;
  }
};

inline flatbuffers::Offset<GraphicSystem> CreateGraphicSystem(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<flatbuffers::String> windowName = 0,
   const Schema::vector2 *resolution = 0,
   const Schema::vector2 *shadowTexture = 0,
   const Schema::vector2 *fsAntiAliasing = 0,
   uint8_t verticalSync = 0,
   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ResourceLocation>>> resources = 0) {
  GraphicSystemBuilder builder_(_fbb);
  builder_.add_resources(resources);
  builder_.add_fsAntiAliasing(fsAntiAliasing);
  builder_.add_shadowTexture(shadowTexture);
  builder_.add_resolution(resolution);
  builder_.add_windowName(windowName);
  builder_.add_verticalSync(verticalSync);
  return builder_.Finish();
}

}  // namespace Systems
}  // namespace Schema

#endif  // FLATBUFFERS_GENERATED_GRAPHICSYSTEM_SCHEMA_SYSTEMS_H_
