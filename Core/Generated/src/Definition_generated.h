// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_DEFINITION_SCHEMA_H_
#define FLATBUFFERS_GENERATED_DEFINITION_SCHEMA_H_

#include "flatbuffers/flatbuffers.h"

#include "Common_generated.h"

namespace Schema {
struct vector2;
struct Property;
struct SystemObject;
struct Object;
struct System;
}  // namespace Schema

namespace Schema {

struct Scene;
struct Link;

struct Scene FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  const flatbuffers::String *name() const { return GetPointer<const flatbuffers::String *>(4); }
  const flatbuffers::Vector<flatbuffers::Offset<Schema::System>> *systems() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Schema::System>> *>(6); }
  const flatbuffers::Vector<flatbuffers::Offset<Schema::Object>> *templates() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Schema::Object>> *>(8); }
  const flatbuffers::Vector<flatbuffers::Offset<Schema::Object>> *objects() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Schema::Object>> *>(10); }
  const flatbuffers::Vector<flatbuffers::Offset<Link>> *links() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Link>> *>(12); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, 4 /* name */) &&
           verifier.Verify(name()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 6 /* systems */) &&
           verifier.Verify(systems()) &&
           verifier.VerifyVectorOfTables(systems()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 8 /* templates */) &&
           verifier.Verify(templates()) &&
           verifier.VerifyVectorOfTables(templates()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 10 /* objects */) &&
           verifier.Verify(objects()) &&
           verifier.VerifyVectorOfTables(objects()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 12 /* links */) &&
           verifier.Verify(links()) &&
           verifier.VerifyVectorOfTables(links()) &&
           verifier.EndTable();
  }
};

struct SceneBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) { fbb_.AddOffset(4, name); }
  void add_systems(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Schema::System>>> systems) { fbb_.AddOffset(6, systems); }
  void add_templates(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Schema::Object>>> templates) { fbb_.AddOffset(8, templates); }
  void add_objects(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Schema::Object>>> objects) { fbb_.AddOffset(10, objects); }
  void add_links(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Link>>> links) { fbb_.AddOffset(12, links); }
  SceneBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  SceneBuilder &operator=(const SceneBuilder &);
  flatbuffers::Offset<Scene> Finish() {
    auto o = flatbuffers::Offset<Scene>(fbb_.EndTable(start_, 5));
    fbb_.Required(o, 4);  // name
    return o;
  }
};

inline flatbuffers::Offset<Scene> CreateScene(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<flatbuffers::String> name = 0,
   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Schema::System>>> systems = 0,
   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Schema::Object>>> templates = 0,
   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Schema::Object>>> objects = 0,
   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Link>>> links = 0) {
  SceneBuilder builder_(_fbb);
  builder_.add_links(links);
  builder_.add_objects(objects);
  builder_.add_templates(templates);
  builder_.add_systems(systems);
  builder_.add_name(name);
  return builder_.Finish();
}

struct Link FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  const flatbuffers::String *subject() const { return GetPointer<const flatbuffers::String *>(4); }
  const flatbuffers::String *observer() const { return GetPointer<const flatbuffers::String *>(6); }
  int16_t subjectSystemType() const { return GetField<int16_t>(8, 0); }
  int16_t observerSystemType() const { return GetField<int16_t>(10, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 4 /* subject */) &&
           verifier.Verify(subject()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 6 /* observer */) &&
           verifier.Verify(observer()) &&
           VerifyField<int16_t>(verifier, 8 /* subjectSystemType */) &&
           VerifyField<int16_t>(verifier, 10 /* observerSystemType */) &&
           verifier.EndTable();
  }
};

struct LinkBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_subject(flatbuffers::Offset<flatbuffers::String> subject) { fbb_.AddOffset(4, subject); }
  void add_observer(flatbuffers::Offset<flatbuffers::String> observer) { fbb_.AddOffset(6, observer); }
  void add_subjectSystemType(int16_t subjectSystemType) { fbb_.AddElement<int16_t>(8, subjectSystemType, 0); }
  void add_observerSystemType(int16_t observerSystemType) { fbb_.AddElement<int16_t>(10, observerSystemType, 0); }
  LinkBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  LinkBuilder &operator=(const LinkBuilder &);
  flatbuffers::Offset<Link> Finish() {
    auto o = flatbuffers::Offset<Link>(fbb_.EndTable(start_, 4));
    return o;
  }
};

inline flatbuffers::Offset<Link> CreateLink(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<flatbuffers::String> subject = 0,
   flatbuffers::Offset<flatbuffers::String> observer = 0,
   int16_t subjectSystemType = 0,
   int16_t observerSystemType = 0) {
  LinkBuilder builder_(_fbb);
  builder_.add_observer(observer);
  builder_.add_subject(subject);
  builder_.add_observerSystemType(observerSystemType);
  builder_.add_subjectSystemType(subjectSystemType);
  return builder_.Finish();
}

inline const Scene *GetScene(const void *buf) { return flatbuffers::GetRoot<Scene>(buf); }

inline bool VerifySceneBuffer(flatbuffers::Verifier &verifier) { return verifier.VerifyBuffer<Scene>(); }

inline void FinishSceneBuffer(flatbuffers::FlatBufferBuilder &fbb, flatbuffers::Offset<Scene> root) { fbb.Finish(root); }

}  // namespace Schema

#endif  // FLATBUFFERS_GENERATED_DEFINITION_SCHEMA_H_
